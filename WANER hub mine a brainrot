-- Waner Hub for Mine a Brainrot (Fixed Auto Discard + Auto Key Storage)
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local Player = Players.LocalPlayer

-- Key System Variables (Hidden)
local validBasicKey = "Wene-you"
local validPremiumKey = "Wene-Premium"
local basicKeyExpiry = 86400 -- 24 hours
local userKeyType = "none"
local keyExpireTime = 0

-- Key Storage in game's DataStore (persisten across sessions)
local keyStorageKey = "WanerHub_Key_" .. Player.UserId

-- Load saved key data from game storage
local function loadKeyData()
    if isfile and readfile then
        pcall(function()
            if isfile(keyStorageKey .. ".txt") then
                local data = readfile(keyStorageKey .. ".txt")
                local keyInfo = data:split("|")
                
                if #keyInfo >= 2 then
                    userKeyType = keyInfo[1]
                    keyExpireTime = tonumber(keyInfo[2]) or 0
                    
                    -- Check if basic key expired
                    if userKeyType == "basic" and os.time() >= keyExpireTime then
                        userKeyType = "none"
                        keyExpireTime = 0
                        saveKeyData() -- Update file
                    end
                end
            end
        end)
    end
end

-- Save key data to game storage
local function saveKeyData()
    if writefile then
        pcall(function()
            local data = userKeyType .. "|" .. keyExpireTime
            writefile(keyStorageKey .. ".txt", data)
        end)
    end
end

-- Position Save System
local savedPositions = {
    endMinePosition = nil,
    customPosition = nil
}

-- Mining Settings
local miningSettings = {
    autoTpBase = false,
    autoTpEnd = false,
    autoLevel = false,
    autoMine = false,
    superFastMine = false,
    autoDiscard = false,
    clickSpeed = 0.1,
    superSpeed = 0.05,
    discardItems = {
        common = true,
        rare = true,
        epic = true,
        legendary = true,
        limited = true,
        mythical = false -- Always keep mythical
    }
}

local connections = {}

-- Load saved key on startup
loadKeyData()

-- Create Window
local Window = Rayfield:CreateWindow({
    Name = "Waner Hub | Mine a Brainrot",
    LoadingTitle = "Waner Hub",
    LoadingSubtitle = "by Waner",
    ConfigurationSaving = {
        Enabled = false
    }
})

-- Key Tab
local KeyTab = Window:CreateTab("üîë Key System")

local KeySection = KeyTab:CreateSection("Authentication")

local KeyStatus = KeyTab:CreateParagraph({
    Title = "Key Status",
    Content = "Status: Loading...\nType: Checking...\nAccess: Verifying..."
})

-- Update key status display with time remaining
local function updateKeyStatus()
    if userKeyType == "premium" then
        KeyStatus:Set({
            Title = "Key Status",
            Content = "Status: ‚úÖ Valid Premium Key\nType: Premium (Permanent)\nAccess: Full Features\n\nüíé No need to enter key again!"
        })
    elseif userKeyType == "basic" then
        if os.time() < keyExpireTime then
            local timeLeft = keyExpireTime - os.time()
            local hoursLeft = math.floor(timeLeft / 3600)
            local minutesLeft = math.floor((timeLeft % 3600) / 60)
            
            KeyStatus:Set({
                Title = "Key Status",
                Content = "Status: ‚úÖ Valid Basic Key\nType: Basic (" .. hoursLeft .. "h " .. minutesLeft .. "m left)\nAccess: Limited Features\n\n‚≠ê Auto-saved until expires!"
            })
        else
            userKeyType = "none"
            keyExpireTime = 0
            saveKeyData()
            KeyStatus:Set({
                Title = "Key Status",
                Content = "Status: ‚è∞ Basic Key Expired\nType: None\nAccess: Denied\n\nüîë Please enter key again!"
            })
        end
    else
        KeyStatus:Set({
            Title = "Key Status",
            Content = "Status: ‚ùå No Valid Key\nType: None\nAccess: Denied\n\nüîë Please enter your key!"
        })
    end
end

-- Initial status update
updateKeyStatus()

-- Show welcome message based on saved key
if userKeyType == "premium" then
    Rayfield:Notify({
        Title = "Welcome Back!",
        Content = "Premium key auto-loaded! Full access ready.",
        Duration = 5
    })
elseif userKeyType == "basic" and os.time() < keyExpireTime then
    local timeLeft = keyExpireTime - os.time()
    local hoursLeft = math.floor(timeLeft / 3600)
    Rayfield:Notify({
        Title = "Welcome Back!",
        Content = "Basic key auto-loaded! " .. hoursLeft .. " hours remaining.",
        Duration = 5
    })
end

-- Reset Key Button
KeyTab:CreateButton({
    Name = "üîÑ End Key Period / Reset Key",
    Callback = function()
        userKeyType = "none"
        keyExpireTime = 0
        saveKeyData()
        
        -- Stop all features
        for _, conn in pairs(connections) do
            if conn then conn:Disconnect() end
        end
        connections = {}
        
        miningSettings.autoTpBase = false
        miningSettings.autoTpEnd = false
        miningSettings.autoLevel = false
        miningSettings.autoMine = false
        miningSettings.superFastMine = false
        miningSettings.autoDiscard = false
        
        updateKeyStatus()
        
        Rayfield:Notify({
            Title = "Key Reset Successfully",
            Content = "Key data cleared. You need to enter key again.",
            Duration = 5
        })
    end
})

-- Key Input (only show if no valid key)
if userKeyType == "none" or (userKeyType == "basic" and os.time() >= keyExpireTime) then
    KeyTab:CreateInput({
        Name = "Enter Your Key",
        PlaceholderText = "Enter your premium or basic key here",
        RemoveTextAfterFocusLost = false,
        Callback = function(Text)
            if Text == validBasicKey then
                userKeyType = "basic"
                keyExpireTime = os.time() + basicKeyExpiry
                saveKeyData()
                updateKeyStatus()
                
                Rayfield:Notify({
                    Title = "Basic Key Accepted",
                    Content = "24-hour access granted and saved! No need to enter again until expired.",
                    Duration = 6
                })
            elseif Text == validPremiumKey then
                userKeyType = "premium"
                keyExpireTime = 0
                saveKeyData()
                updateKeyStatus()
                
                Rayfield:Notify({
                    Title = "Premium Key Accepted",
                    Content = "Permanent access granted and saved! Never expires.",
                    Duration = 6
                })
            else
                Rayfield:Notify({
                    Title = "Invalid Key",
                    Content = "The key you entered is invalid. Please try again.",
                    Duration = 4
                })
            end
        end
    })
end

KeyTab:CreateSection("Key Information")

KeyTab:CreateParagraph({
    Title = "Auto-Save System",
    Content = "‚úÖ Keys are automatically saved!\n‚Ä¢ Basic Key: Saved for 24 hours\n‚Ä¢ Premium Key: Saved permanently\n‚Ä¢ Only need to re-enter after reset or expiry\n\nContact developer for keys."
})

-- Check if key is valid
local function isKeyValid()
    if userKeyType == "premium" then
        return true
    elseif userKeyType == "basic" then
        return os.time() < keyExpireTime
    end
    return false
end

-- Function to show access denied message
local function showAccessDenied()
    Rayfield:Notify({
        Title = "Access Denied", 
        Content = "Please enter key first!", 
        Duration = 3
    })
end

-- Auto Tap/Click Functions
local function performAutoTap()
    pcall(function()
        local screenSize = workspace.CurrentCamera.ViewportSize
        local centerX = screenSize.X / 2
        local centerY = screenSize.Y / 2
        
        VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 0)
        wait(0.01)
        VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 0)
        
        for _, remote in pairs(ReplicatedStorage:GetDescendants()) do
            if remote:IsA("RemoteEvent") then
                if string.find(remote.Name:lower(), "click") or 
                   string.find(remote.Name:lower(), "tap") or 
                   string.find(remote.Name:lower(), "mine") or
                   string.find(remote.Name:lower(), "dig") then
                    remote:FireServer()
                end
            end
        end
        
        local character = Player.Character
        if character then
            local tool = character:FindFirstChildOfClass("Tool")
            if tool then
                tool:Activate()
            end
        end
    end)
end

-- FIXED Auto Discard Function
local function performAutoDiscard()
    if not miningSettings.autoDiscard or userKeyType ~= "premium" then
        return
    end
    
    pcall(function()
        -- Get all items from backpack and character
        local allItems = {}
        
        -- Add backpack items
        for _, item in pairs(Player.Backpack:GetChildren()) do
            if item:IsA("Tool") then
                table.insert(allItems, item)
            end
        end
        
        -- Add character items (equipped tools)
        local character = Player.Character
        if character then
            for _, item in pairs(character:GetChildren()) do
                if item:IsA("Tool") then
                    table.insert(allItems, item)
                end
            end
        end
        
        -- Process each item
        for _, item in pairs(allItems) do
            local shouldDiscard = false
            local itemRarity = "common" -- default rarity
            
            -- Method 1: Check StringValue/IntValue for rarity
            for _, child in pairs(item:GetChildren()) do
                if child.Name:lower() == "rarity" or child.Name:lower() == "tier" then
                    if child:IsA("StringValue") then
                        itemRarity = child.Value:lower()
                    elseif child:IsA("IntValue") then
                        -- Convert number to rarity
                        local rarityNum = child.Value
                        if rarityNum >= 6 then
                            itemRarity = "mythical"
                        elseif rarityNum == 5 then
                            itemRarity = "legendary"
                        elseif rarityNum == 4 then
                            itemRarity = "epic"
                        elseif rarityNum == 3 then
                            itemRarity = "rare"
                        elseif rarityNum == 2 then
                            itemRarity = "uncommon"
                        else
                            itemRarity = "common"
                        end
                    end
                    break
                end
            end
            
            -- Method 2: Check item name for rarity keywords
            local itemName = item.Name:lower()
            if string.find(itemName, "mythical") or string.find(itemName, "mythic") then
                itemRarity = "mythical"
            elseif string.find(itemName, "legendary") or string.find(itemName, "legend") then
                itemRarity = "legendary"  
            elseif string.find(itemName, "epic") then
                itemRarity = "epic"
            elseif string.find(itemName, "rare") then
                itemRarity = "rare"
            elseif string.find(itemName, "limited") then
                itemRarity = "limited"
            end
            
            -- Method 3: Check item color/BrickColor for rarity
            if item:FindFirstChildOfClass("Part") then
                local part = item:FindFirstChildOfClass("Part")
                local color = part.Color
                
                -- Common rarity colors (you may need to adjust these)
                if color == Color3.new(0.5, 0.5, 0.5) then -- Gray
                    itemRarity = "common"
                elseif color == Color3.new(0, 1, 0) then -- Green  
                    itemRarity = "rare"
                elseif color == Color3.new(0, 0, 1) then -- Blue
                    itemRarity = "epic"
                elseif color == Color3.new(1, 0, 1) then -- Purple
                    itemRarity = "legendary"
                elseif color == Color3.new(1, 1, 0) then -- Yellow/Gold
                    itemRarity = "mythical"
                end
            end
            
            -- Determine if should discard based on settings
            if itemRarity == "mythical" or itemRarity == "mythic" then
                shouldDiscard = miningSettings.discardItems.mythical -- Should be false (keep mythical)
            elseif itemRarity == "legendary" or itemRarity == "legend" then
                shouldDiscard = miningSettings.discardItems.legendary
            elseif itemRarity == "epic" then
                shouldDiscard = miningSettings.discardItems.epic
            elseif itemRarity == "rare" then
                shouldDiscard = miningSettings.discardItems.rare
            elseif itemRarity == "limited" then
                shouldDiscard = miningSettings.discardItems.limited
            else
                shouldDiscard = miningSettings.discardItems.common
            end
            
            -- Discard item if needed
            if shouldDiscard then
                local discarded = false
                
                -- Method 1: Try game-specific sell/discard remotes
                for _, remote in pairs(ReplicatedStorage:GetDescendants()) do
                    if remote:IsA("RemoteEvent") then
                        local remoteName = remote.Name:lower()
                        if string.find(remoteName, "sell") or 
                           string.find(remoteName, "delete") or
                           string.find(remoteName, "discard") or
                           string.find(remoteName, "trash") or
                           string.find(remoteName, "remove") then
                            
                            -- Try different parameter formats
                            remote:FireServer(item)
                            remote:FireServer(item.Name)
                            remote:FireServer({item})
                            discarded = true
                            break
                        end
                    end
                end
                
                -- Method 2: Try GUI sell buttons
                if not discarded then
                    for _, gui in pairs(Player.PlayerGui:GetDescendants()) do
                        if gui:IsA("TextButton") or gui:IsA("ImageButton") then
                            local buttonText = gui.Text:lower()
                            if string.find(buttonText, "sell") or string.find(buttonText, "delete") then
                                firesignal(gui.MouseButton1Click)
                                discarded = true
                                break
                            end
                        end
                    end
                end
                
                -- Method 3: Destroy as last resort
                wait(0.1)
                if item and item.Parent then
                    item:Destroy()
                    discarded = true
                end
                
                if discarded then
                    print("üóëÔ∏è Discarded " .. itemRarity .. " item: " .. item.Name)
                end
            else
                print("‚úÖ Keeping " .. itemRarity .. " item: " .. item.Name)
            end
        end
    end)
end

-- Position Save Functions
local function saveCurrentPosition()
    local character = Player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        return character.HumanoidRootPart.CFrame
    end
    return nil
end

local function teleportToPosition(cframe)
    local character = Player.Character
    if character and character:FindFirstChild("HumanoidRootPart") and cframe then
        character.HumanoidRootPart.CFrame = cframe
        return true
    end
    return false
end

-- Basic Tab
local BasicTab = Window:CreateTab("‚≠ê Basic Features")

BasicTab:CreateSection("Basic Mining Tools")

if not isKeyValid() then
    BasicTab:CreateParagraph({
        Title = "Access Restricted",
        Content = "‚ùå Please enter a valid key in the Key System tab to access Basic features."
    })
else
    BasicTab:CreateParagraph({
        Title = "Basic Features Info",
        Content = "‚úÖ Basic features available:\n‚Ä¢ Auto TP to Base\n‚Ä¢ Auto Level to End"
    })
end

BasicTab:CreateToggle({
    Name = "Auto TP to Base",
    CurrentValue = false,
    Callback = function(Value)
        if not isKeyValid() then
            showAccessDenied()
            return
        end
        
        miningSettings.autoTpBase = Value
        
        if Value then
            connections["tpBase"] = RunService.Heartbeat:Connect(function()
                if not miningSettings.autoTpBase then return end
                
                pcall(function()
                    local char = Player.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        if workspace:FindFirstChild("Spawn") then
                            char.HumanoidRootPart.CFrame = workspace.Spawn.CFrame * CFrame.new(0, 5, 0)
                        end
                    end
                end)
                
                wait(2)
            end)
        else
            if connections["tpBase"] then
                connections["tpBase"]:Disconnect()
                connections["tpBase"] = nil
            end
        end
    end
})

BasicTab:CreateToggle({
    Name = "Auto Level to End",
    CurrentValue = false,
    Callback = function(Value)
        if not isKeyValid() then
            showAccessDenied()
            return
        end
        
        miningSettings.autoLevel = Value
        
        if Value then
            connections["autoLevel"] = RunService.Heartbeat:Connect(function()
                if not miningSettings.autoLevel then return end
                
                pcall(function()
                    for _, v in pairs(ReplicatedStorage:GetDescendants()) do
                        if v:IsA("RemoteEvent") or v:IsA("RemoteFunction") then
                            if string.find(v.Name:lower(), "rebirth") or 
                               string.find(v.Name:lower(), "prestige") or
                               string.find(v.Name:lower(), "evolve") then
                                if v:IsA("RemoteEvent") then
                                    v:FireServer()
                                else
                                    v:InvokeServer()
                                end
                            end
                        end
                    end
                end)
                
                wait(1)
            end)
        else
            if connections["autoLevel"] then
                connections["autoLevel"]:Disconnect()
                connections["autoLevel"] = nil
            end
        end
    end
})

-- Premium Tab
local PremiumTab = Window:CreateTab("üíé Premium Features")

PremiumTab:CreateSection("Premium Mining Tools")

local function checkPremium()
    if userKeyType == "none" then
        showAccessDenied()
        return false
    elseif userKeyType ~= "premium" then
        Rayfield:Notify({
            Title = "Premium Required",
            Content = "Need premium! You not have access",
            Duration = 5
        })
        return false
    end
    return true
end

if userKeyType ~= "premium" then
    PremiumTab:CreateParagraph({
        Title = "Premium Access Required",
        Content = "‚ùå Premium key required for:\n‚Ä¢ Auto TP to End Mine\n‚Ä¢ Auto Mine (Auto Tap Screen)\n‚Ä¢ Super Fast Mine (Rapid Tap)\n‚Ä¢ Position Save System\n‚Ä¢ Auto Item Discard"
    })
else
    PremiumTab:CreateParagraph({
        Title = "Premium Features Available",
        Content = "‚úÖ All premium features unlocked!\n‚Ä¢ Auto TP to End Mine\n‚Ä¢ Auto Mine & Super Fast Mine\n‚Ä¢ Position Save System\n‚Ä¢ Auto Item Discard"
    })
end

PremiumTab:CreateToggle({
    Name = "Auto TP to End Mine",
    CurrentValue = false,
    Callback = function(Value)
        if not checkPremium() then return end
        
        miningSettings.autoTpEnd = Value
        
        if Value then
            connections["tpEnd"] = RunService.Heartbeat:Connect(function()
                if not miningSettings.autoTpEnd then return end
                
                pcall(function()
                    local char = Player.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        if savedPositions.endMinePosition then
                            char.HumanoidRootPart.CFrame = savedPositions.endMinePosition
                        else
                            for _, v in pairs(workspace:GetChildren()) do
                                if string.find(v.Name:lower(), "mine") or 
                                   string.find(v.Name:lower(), "deep") or
                                   string.find(v.Name:lower(), "end") then
                                    if v:FindFirstChild("Part") or v:IsA("Part") then
                                        local targetCF = v:IsA("Part") and v.CFrame or v:FindFirstChildWhichIsA("Part").CFrame
                                        char.HumanoidRootPart.CFrame = targetCF * CFrame.new(0, 5, 0)
                                        
                                        savedPositions.endMinePosition = targetCF * CFrame.new(0, 5, 0)
                                        
                                        Rayfield:Notify({
                                            Title = "Position Auto-Saved",
                                            Content = "End mine position saved!",
                                            Duration = 3
                                        })
                                        break
                                    end
                                end
                            end
                        end
                    end
                end)
                
                wait(3)
            end)
        else
            if connections["tpEnd"] then
                connections["tpEnd"]:Disconnect()
                connections["tpEnd"] = nil
            end
        end
    end
})

PremiumTab:CreateToggle({
    Name = "Auto Mine (Auto Tap Screen)",
    CurrentValue = false,
    Callback = function(Value)
        if not checkPremium() then return end
        
        miningSettings.autoMine = Value
        
        if Value then
            Rayfield:Notify({
                Title = "Auto Mine Started",
                Content = "Auto tapping screen...",
                Duration = 3
            })
            
            connections["autoMine"] = RunService.Heartbeat:Connect(function()
                if not miningSettings.autoMine then return end
                
                performAutoTap()
                wait(miningSettings.clickSpeed)
            end)
        else
            if connections["autoMine"] then
                connections["autoMine"]:Disconnect()
                connections["autoMine"] = nil
            end
        end
    end
})

PremiumTab:CreateToggle({
    Name = "Super Fast Mine (Rapid Tap)",
    CurrentValue = false,
    Callback = function(Value)
        if not checkPremium() then return end
        
        miningSettings.superFastMine = Value
        
        if Value then
            Rayfield:Notify({
                Title = "Super Fast Mine Started",
                Content = "Rapid tapping at max speed!",
                Duration = 3
            })
            
            connections["superFast"] = RunService.Heartbeat:Connect(function()
                if not miningSettings.superFastMine then return end
                
                for i = 1, 5 do
                    performAutoTap()
                end
                wait(miningSettings.superSpeed)
            end)
        else
            if connections["superFast"] then
                connections["superFast"]:Disconnect()
                connections["superFast"] = nil
            end
        end
    end
})

-- Position Management Section
PremiumTab:CreateSection("Position Management System")

local PositionStatus = PremiumTab:CreateParagraph({
    Title = "Saved Positions",
    Content = "End Mine Position: ‚ùå Not Saved\nCustom Position: ‚ùå Not Saved"
})

local function updatePositionStatus()
    local endStatus = savedPositions.endMinePosition and "‚úÖ Saved" or "‚ùå Not Saved"
    local customStatus = savedPositions.customPosition and "‚úÖ Saved" or "‚ùå Not Saved"
    
    PositionStatus:Set({
        Title = "Saved Positions",
        Content = "End Mine Position: " .. endStatus .. "\nCustom Position: " .. customStatus
    })
end

PremiumTab:CreateButton({
    Name = "üíæ Save Current as End Mine",
    Callback = function()
        if not checkPremium() then return end
        
        local currentPos = saveCurrentPosition()
        if currentPos then
            savedPositions.endMinePosition = currentPos
            updatePositionStatus()
            Rayfield:Notify({
                Title = "Position Saved",
                Content = "End Mine position saved!",
                Duration = 4
            })
        end
    end
})

PremiumTab:CreateButton({
    Name = "üìç Save Current as Custom",
    Callback = function()
        if not checkPremium() then return end
        
        local currentPos = saveCurrentPosition()
        if currentPos then
            savedPositions.customPosition = currentPos
            updatePositionStatus()
            Rayfield:Notify({
                Title = "Position Saved",
                Content = "Custom position saved!",
                Duration = 4
            })
        end
    end
})

PremiumTab:CreateButton({
    Name = "üöÄ TP to End Mine",
    Callback = function()
        if not checkPremium() then return end
        
        if savedPositions.endMinePosition then
            if teleportToPosition(savedPositions.endMinePosition) then
                Rayfield:Notify({
                    Title = "Teleported",
                    Content = "Went to End Mine position!",
                    Duration = 3
                })
            end
        else
            Rayfield:Notify({
                Title = "No Position Saved",
                Content = "Save End Mine position first!",
                Duration = 3
            })
        end
    end
})

PremiumTab:CreateButton({
    Name = "üéØ TP to Custom",
    Callback = function()
        if not checkPremium() then return end
        
        if savedPositions.customPosition then
            if teleportToPosition(savedPositions.customPosition) then
                Rayfield:Notify({
                    Title = "Teleported",
                    Content = "Went to Custom position!",
                    Duration = 3
                })
            end
        else
            Rayfield:Notify({
                Title = "No Position Saved",
                Content = "Save Custom position first!",
                Duration = 3
            })
        end
    end
})

-- Item Manager Tab
local ItemTab = Window:CreateTab("üì¶ Item Manager")

ItemTab:CreateSection("Auto Discard System (Premium Only)")

if userKeyType ~= "premium" then
    ItemTab:CreateParagraph({
        Title = "Premium Required",
        Content = "‚ùå Auto Item Discard requires Premium key.\n\nThis system will automatically discard items by rarity and keep only what you want."
    })
else
    ItemTab:CreateParagraph({
        Title = "Auto Discard Active",
        Content = "‚úÖ Premium Auto Discard System Ready!\n\nConfigure what items to keep/discard below.\nRecommended: Keep only Mythical items."
    })
end

ItemTab:CreateToggle({
    Name = "üî• Enable Auto Discard",
    CurrentValue = false,
    Callback = function(Value)
        if not checkPremium() then return end
        
        miningSettings.autoDiscard = Value
        
        if Value then
            Rayfield:Notify({
                Title = "Auto Discard Enabled",
                Content = "Will discard items based on your settings every 3 seconds.",
                Duration = 4
            })
        else
            Rayfield:Notify({
                Title = "Auto Discard Disabled",
                Content = "Items will no longer be auto-discarded.",
                Duration = 3
            })
        end
    end
})

ItemTab:CreateSection("Discard Settings")

ItemTab:CreateToggle({
    Name = "Discard Common Items",
    CurrentValue = true,
    Callback = function(Value)
        if not checkPremium() then return end
        miningSettings.discardItems.common = Value
    end
})

ItemTab:CreateToggle({
    Name = "Discard Rare Items", 
    CurrentValue = true,
    Callback = function(Value)
        if not checkPremium() then return end
        miningSettings.discardItems.rare = Value
    end
})

ItemTab:CreateToggle({
    Name = "Discard Epic Items",
    CurrentValue = true,
    Callback = function(Value)
        if not checkPremium() then return end
        miningSettings.discardItems.epic = Value
    end
})

ItemTab:CreateToggle({
    Name = "Discard Legendary Items",
    CurrentValue = true,
    Callback = function(Value)
        if not checkPremium() then return end
        miningSettings.discardItems.legendary = Value
    end
})

ItemTab:CreateToggle({
    Name = "Discard Limited Items",
    CurrentValue = true,
    Callback = function(Value)
        if not checkPremium() then return end
        miningSettings.discardItems.limited = Value
    end
})

ItemTab:CreateToggle({
    Name = "Keep Mythical Items (Recommended ON)",
    CurrentValue = true,
    Callback = function(Value)
        if not checkPremium() then return end
        miningSettings.discardItems.mythical = not Value -- Inverted because we want to KEEP mythical
        
        if Value then
            Rayfield:Notify({
                Title = "Mythical Protected",
                Content = "Mythical items will be kept safe!",
                Duration = 3
            })
        else
            Rayfield:Notify({
                Title = "Warning",
                Content = "Mythical items will be discarded too!",
                Duration = 4
            })
        end
    end
})

-- Auto discard loop (runs every 3 seconds)
spawn(function()
    while wait(3) do
        if miningSettings.autoDiscard and userKeyType == "premium" then
            performAutoDiscard()
        end
    end
end)

-- Key expiry check (runs every minute)
spawn(function()
    while wait(60) do
        if userKeyType == "basic" and keyExpireTime > 0 and os.time() >= keyExpireTime then
            -- Basic key expired
            userKeyType = "none"
            keyExpireTime = 0
            saveKeyData()
            
            -- Stop all features
            for _, conn in pairs(connections) do
                if conn then conn:Disconnect() end
            end
            connections = {}
            
            miningSettings.autoTpBase = false
            miningSettings.autoTpEnd = false
            miningSettings.autoLevel = false
            miningSettings.autoMine = false
            miningSettings.superFastMine = false
            miningSettings.autoDiscard = false
            
            updateKeyStatus()
            
            Rayfield:Notify({
                Title = "Key Expired",
                Content = "Your 24-hour basic key has expired! Please enter a new key.",
                Duration = 8
            })
        end
        
        -- Update status every minute
        if userKeyType == "basic" then
            updateKeyStatus()
        end
    end
end)

-- Initialize
updatePositionStatus()

print("üîë Waner Hub loaded - Auto-save key system ready!")
print("üóëÔ∏è Enhanced auto discard system loaded!")
print("üíæ Position save system ready!")
